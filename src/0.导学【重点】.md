1. 清楚两个概念：

    库：小而巧的库，只提供了特定的api。优点：船小好掉头

    框架：大而全的是框架。 框架提供了一整套的解决方案。所以，如果在项目中间，想切换到另外的框架，是比较困难的。



2. 前端三大框架

    三大框架一大抄

    angular 最早 2009年 google

    vue 早火（观望的最多）

    react 最流行 （用的最多） 2013年 facebook


3. React和vue对比

    **模块化：是从代码角度进行分析的。把一些可复用的代码抽离为单个模块。好处：便于项目的维护和开发。**

    **组件化：是从UI界面角度进行分析的。把一些可复用的UI元素抽离为单个组件。**

    大家注意，**React 中有组件化的概念，但是，并没有像vue这样的组件模板文件。**

    **在React中，一切都是以 JS 来表现的。**

    因此，要学习React, JS要合格。 ES6 和 ES7 （async await） 要会用。


4. 开发团队方面

    React 是由 Facebook 前端官方团队进行维护和更新的。因此，React 的维护开发团队，技术实力比较雄厚

    Vue 第一版，主要是有作者尤雨溪专门进行维护的，当 vue更新到 2.x版本之后，也有了一个以尤雨溪为主导的开源小团队，进行相关的开发和维护。


5. 社区方面

    在社区方面，React 由于诞生的较早，所以社区比较强大，一些常见的问题、坑、最优解决方案、文档、博客在社区中都可以很方便的找到。

    Vue 是最近两年才火起来的，所以它的社区相对于React来说，要小一些，可能有的一些坑、没有彩过。


6. 移动app开发体验方面

    React，结合 ReactNative，也提供了无缝迁移到移动app的开发体验。（RN用的最多，也是最火最流行的）。**注意，要想学ReactNative，一定要先学会React语法**

    Vue，结合 weex这门技术，提供了迁移到移动端app开发的体验（weex，目前只是一个小的玩具，并没有很成功的大案例）**要想学Weex，也要先学会Vue语法**


7. 为什么要学习React

    **React设计思想很优秀，一切基于JS并用实现了组件化开发的思想**。

    开发团队实力强悍，不必担心断更的情况

    社区强大，很多问题都能找到对应的解决方案

    提供了无缝转到 ReactNative 上的开发体验，让我们技术能力得到了拓展，增强了我们的核心竞争力

    很多企业中，前端项目的技术选型采用的是 React.js



8. React 中的几个核心概念

    虚拟DOM

    Diff 算法

    语法



9. 虚拟DOM

    **DOM**的本质是什么：**浏览器**中的概念，**用JS对象来表示页面上的元素**，并提供了操作DOM对象的API

    什么是React中的**虚拟DOM**：是**框架**中的概念，是开发框架的程序员，手动**用JS对象来模拟**页面上的DOM元素和DOM嵌套关系

    为什么要实现虚拟DOM（虚拟DOM的**目的**）：**为了实现页面中，DOM元素的高效更新**



10. 演示虚拟DOM的目的：

    * 需求：点击表格中的列头，实现对应表格数据的排序。


    * 表格中的数据从哪里来的？

    从数据库查询回来的。（走ajax和网络）



    * 这些查询到的数据，存到哪儿了？

    这些数据在浏览器的内存存放着，而且是以对象数组的形式来表示的。



    * 这些数据，是怎么渲染到页面上的？

    方案一：手动for循环整个数组，然后手动拼接字符串，str += '<tr></tr>'，然后 append到页面上

    方案二：使用模板引擎，如handlebars

    这两者本质上都一样，使用的都是for循环，唯一区别就是使用模板引擎方便了程序员




    * 思考：上述的方案有没有性能上的问题？

    如果用户点击了【时间】列，想按照时间从大到小排序：

        1.触发点击事件，在事件中把内存中的对象数组重新排序

        2.当排序完后，页面是旧的，但是内存中的对象数组是新的

        3.想办法，把最新的数组，重新渲染到页面上。（有没有性能上的问题）

    如果只有前两行数据变化，后面几行数据都没有发生变化，重新渲染数据会有性能上的损耗（因为DOM操作会涉及页面的重绘与回流，所以应该尽量减少DOM操作）。

    方案一和方案二都无法实现性能上的需求。

    怎么办才能实现？

    按需更新。




    

    * 分析与总结：上述方案，只量实现了把数据渲染到页面上的能力，但是并没有把性能做到最优。

    如何才能把性能做到最优： **按需渲染**页面（**只重新渲染更新的数据**所对应的页面元素）

    如何实现按需渲染：




    * 先了解下 DOM树 的概念：

    一个网页呈现的过程：

        1.浏览器请求服务器获取页面的HTML代码

        2.浏览器要在现在内存中，解析DOM结构，并在浏览器内存中，渲染出一棵DOM树

        3.浏览器把DOM树，呈现到页面上

        浏览器中有现成的DOM树
        


    * 如何实现按需更新？

    获取内存中的两棵新旧DOM树，进行对比，得到需要按需更新的DOM元素。

    如何获取到新旧DOM树，从而实现DOM树的对比？

    分析：浏览器中并没有直接提供获取DOM树的api,因此，我们无法拿到浏览器内存中的DOM树

    程序员可以手动模拟两棵新旧DOM树

    程序员如何手动模拟两棵新旧DOM树？如何模拟一个DOM元素？<div id="mydiv" title="说实话" data-index="0">彬哥好帅<p>哈哈哈</p></div>

    分析：学过哪些语言？ HTML，css， js

    哪种语言可以模拟DOM元素？只有 js 可以

    ```js
            var div = {
                tagName: 'div',
                attr: {
                    id: 'mydiv',
                    title: '说实话',
                    'data-index': '0'
                },
                children: [
                    '彬哥好帅',
                    {
                        tagName: 'p',
                        attr: {},
                        children: [
                            '哈哈哈'
                        ]
                    }
                ]
            }
    ```

    这样就用 js 对象，模拟出来了DOM树

    逐层对比新旧DOM树。


    程序员手动模拟的这两棵新旧DOM树，就是React中虚拟DOM的概念

    总结：

    **什么是虚拟DOM： 用js 对象的形式来模拟页面上DOM的嵌套关系**。(虚拟DOM是以对象的形式存在的)

    **本质：用 js 对象来模拟DOM元素和嵌套关系**

    **目的：为了实现页面元素的高效更新**


11. Diff 算法

    只有新旧两棵DOM树的对比高效，才能实现页面元素的高效更新。

    1.tree Diff：每一层之间对比的过程。

    2.component Diff：组件级别的对比，如果对比前后，组件类型相同，则暂时认为此组件不需要被更新。如果对比前后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上。

    3.element Diff：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比。

    通过三个对比，则所有按需更新的元素都会被找到。


12. webpack 4.x

    运行 npm init -y，快速创建一个项目

    dist --- 产品目录 

    src --- 源码目录


    mode 是 webpack 4.x 新增的选项。之前的没有此项。可选的值有 production、development。此选项为必选项。

    webpack 是基于 node 来构建的，所以webpack支持所有 node api和语法 。

    哪些特性 node支持？chrome支持哪些，则 node 就支持。


13. node 与 chrome 的关系

    node 用的就是 chrome 中的 v8 引擎。


14. webpack-dev-server

    cnpm i webpack-dev-server -D

    提升打包性能，提供了默认约定 

    webpack-dev-server 把打包好的文件，托管到了内存中，并没有放到物理磁盘上。



